[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/bruin/HW0.html",
    "href": "posts/bruin/HW0.html",
    "title": "Contructing data visualization of the Palmer Penguin data set",
    "section": "",
    "text": "In this blog, I will be explaining how to construct a data visualization of the Palmer Penguins data set."
  },
  {
    "objectID": "posts/bruin/HW0.html#breakdown-of-the-code",
    "href": "posts/bruin/HW0.html#breakdown-of-the-code",
    "title": "Contructing data visualization of the Palmer Penguin data set",
    "section": "Breakdown of the Code",
    "text": "Breakdown of the Code\nTo generate the interactive plot, we will be using the following code to generate the plot. fig = px.scatter(data_frame = dataset, x = “column name 1”, y = “column name 2”, title = “title of plot”, color = “column name 3”, hover_data = [“other columns to display”], width = num, height = num, opacity = num )\nThe arguments used is:  - data_frame = dataset we are using for this plot - x = a specific column from the data set that will be used on the x-axis - y = a sepcific column from the data set tht will be used on the y-axis - title = main title of the plot - color = the color of the points (can be used to seperate different categories i.e. species of penguins) - hover_data = other column information that you would like to display when user hovers over a specific point (note: the columns used for x, y, and color will already be shown when the user hovers over a specific point) - width = the width of the plot - height = the height of the plot - opacity = allows the point on the plot to be sheer\nWe will now be replacing our data set with the respective column names into the code.\n\nfig = px.scatter(data_frame = penguins,\n                 x = \"Body Mass (g)\",\n                 y = \"Flipper Length (mm)\",\n                 title = \"Body Mass and Flipper Length in Penguin Species\",\n                 color = \"Species\",\n                 hover_data = [\"Individual ID\"],\n                 width = 500,\n                 height = 300,\n                 opacity = 0.5\n                )\n\nfig.update_layout(margin={\"r\":0, \"t\":30, \"l\":0, \"b\":0})\nfig.show()\n\n                                                \n\n\nIf we hover our cursor over the points in the plot, we can see information about the specific point. For this particular example, it is able to show you the type of species, the body mass/flipper length for this particular penguin, and the penguin’s ID number."
  },
  {
    "objectID": "posts/bruin/HW0.html#analysis-of-plot",
    "href": "posts/bruin/HW0.html#analysis-of-plot",
    "title": "Contructing data visualization of the Palmer Penguin data set",
    "section": "Analysis of Plot",
    "text": "Analysis of Plot\nFrom the outputted plot, we can see that Gentoo Penguins have a bigger body mass and longer flippers compared to Adelie and Chinstrap penguins. In addition, we can see the Adelie and Chinstrap penguins have similar body mass and Flipper length. Therefore, there does seem to be a correlation between flipper length and body mass of the penguins. For penguins with bigger body mass, they seem to have longer flippers, while smaller body mass penguins have shorter flippers. It is possible that the bigger penguins will need to have bigger flippers for balance and support!"
  },
  {
    "objectID": "posts/bruin/HW0.html#additional-style-choices",
    "href": "posts/bruin/HW0.html#additional-style-choices",
    "title": "Contructing data visualization of the Palmer Penguin data set",
    "section": "Additional Style Choices",
    "text": "Additional Style Choices\nIn addition, we added a following line of code: fig.update_layout(margin={“r”:0, “t”:0, “l”:0, “b”:0})\nThis allows the plot to look a lot neater when generated. Let me show you the difference of using it and not using it.\n\nfig = px.scatter(data_frame = penguins,\n                 x = \"Body Mass (g)\",\n                 y = \"Flipper Length (mm)\",\n                 title = \"Body Mass and Flipper Length in Penguin Species\",\n                 color = \"Species\",\n                 hover_data = [\"Individual ID\"],\n                 width = 500,\n                 height = 300,\n                 opacity = 0.5\n                )\n\n# fig.update_layout(margin={\"r\":0, \"t\":0, \"l\":0, \"b\":0})\nfig.show()\n\n                                                \n\n\nAbove is what it looks like when we commented out the line of code. The plot looks squashed and not as clear compared to when we adjusted the layout of the plot. There are still a lot of other arguments that you can add to the plot to customize it. More information can be found on this website: https://plotly.com"
  },
  {
    "objectID": "posts/bruin/HW2.html",
    "href": "posts/bruin/HW2.html",
    "title": "Web Scrapping TMDB",
    "section": "",
    "text": "In the blog, we will be learning how to web scrape through TMDB and create a csv file using the library scrapy."
  },
  {
    "objectID": "posts/bruin/HW2.html#parse-function",
    "href": "posts/bruin/HW2.html#parse-function",
    "title": "Web Scrapping TMDB",
    "section": "parse Function",
    "text": "parse Function\nInside our class, we will define another function called parse. This will bring us to the next page that contains the information on the Full Cast and Members.\n\ndef parse(self, response):\n    \"\"\"\n    Parsing through the initial website to get to the cast webpage\n    \"\"\"\n    # getting to the cast page\n    yield scrapy.Request(f\"{response.url}/cast\", \n                         callback = self.parse_full_credits)\n\nIn parse, you can see that we set the first parameter of scrapy.Request to f”{response.url}/cast”. This will take the url that we have selected in the init function, and add on /cast to get to the page with all the cast information."
  },
  {
    "objectID": "posts/bruin/HW2.html#parse_full_credits-function",
    "href": "posts/bruin/HW2.html#parse_full_credits-function",
    "title": "Web Scrapping TMDB",
    "section": "parse_full_credits Function",
    "text": "parse_full_credits Function\nFrom the cast information webpage, we will like to go to each individual actor’s webpage. To do so, we will define another function inside the class called parse_full_credits. What this function will do is go through each actor on the website and call the function parse_actor_page.\n\ndef parse_full_credits(self, response):\n    \"\"\"\n    At the cast webpage, this function will look through all the crew members and \n    get link to their own personal webpage \n    \"\"\"\n    # getting the information from the full cast and members\n    for info in response.css(\"ol.people.credits\")[0].css(\"li\") :\n        # getting the links to the individual actors\n        actor = info.css('a::attr(href)').get() \n        yield scrapy.Request(f\"https://www.themoviedb.org{actor}\", \n                             callback = self.parse_actor_page)\n\nIn parse_full_credits, to get to each individual actor’s page, we will use the following command: response.css(“ol.people.credits”)[0].css(“li”).  How do we know we will need to use this command? We will inspect the webpage.  In the webpage, when we hover over a line, we can see the corresponding section highlighted on the website. We will follow all the subcategories until we find the link to an cast member’s webpage.  To get to that section, we will use response.css(“ol.people.credits”)[0].css(“li”). We will put this under a for loop, which will allow us to parse through each individual actor under Cast.  After getting to a single actor, we will use ‘a::attr(href)’ to get the link to the actor’s page. We will then add on the link to https://www.themoviedb.org, by using the following code: f”https://www.themoviedb.org{actor}“. This will send the link to the next function to be parsed."
  },
  {
    "objectID": "posts/bruin/HW2.html#parse_actor_page-function",
    "href": "posts/bruin/HW2.html#parse_actor_page-function",
    "title": "Web Scrapping TMDB",
    "section": "parse_actor_page Function",
    "text": "parse_actor_page Function\nWe will now define another function inside the class called parse_actor_page. This will scrape through a specific actor’s page and find all the movies and tv shows the actor had an Acting role in.\n\ndef parse_actor_page(self, response):\n    \"\"\"\n    This function will start at the actor's webpage.\n    It will then take all the movies and TV shows this actor had an Acting role in \n    and insert it into a dictionary.\n    \"\"\"\n    # some actor acting informations are not aligned, therefore we will need \n    # to take that into account and use an if statement to find the correct header\n    header_pos = 0\n        \n    if response.css('h3.zero:contains(\"Acting\")') :\n        header_pos = 0\n    elif response.css('h3.one:contains(\"Acting\")') :\n        header_pos = 1\n    elif response.css('h3.two:contains(\"Acting\")'):\n        header_pos = 2\n        \n    actor_acting = response.css(\"table.card.credits\")[header_pos]\n        \n    for work in actor_acting.css(\"a.tooltip bdi::text\").getall():\n        yield {\"actor\" : response.css(\"h2.title a::text\").get(), \n               \"movie_or_TV_name\" : work}\n\nAgain, we will look through inspect to see exactly where the information we need is located. We need to be very careful in this section, as some cast webpages are out of order.  Specifically, when we look at David Holmes webpage, we see that Acting is not displayed first. Instead, Crew is displayed first on his page. Therefore, to figure out where the Acting section is for each actor, we will use an if statement.  Under inspect, we see that h3 contains all the information on the movies and tv shows that actors has been in and whether they were in Acting, Crew, or Production. Therefore, to find the specific h3 that has the information on the movies and tv shows an actor had an Acting role in, we will use the following command: ‘h3.zero:contains(“Acting”)’, ‘h3.one:contains(“Acting”)’ or ‘h3.two:contains(“Acting”)’. This will look through the text in h3 and see if Acting is in the line. If it is, we will then set header_pos.  Next, we will use the command response.css(“table.card.credits”)[header_pos] which will use the position of the header to get to the information on the movies and tv shows the actor has been in.  To get the movie and tv show name, we will use actor_acting.css(“a.tooltip bdi::text”).getall(). This will get the names of all the movies and tv show’s the actor has been in.  Now, we want to add the information into a dictionary. We will for loop through the result and add the titles to the corresponding actor.\nNow that we have completed our code, we can run our code by using the following terminal command:  scrapy crawl tmdb_spider -o movies.csv -a subdir=671-harry-potter-and-the-philosopher-s-stone  If you would like to parse through another movie, simply replace the subdir to another movie’s link.  If you run into any issues, you will have to use an USER_AGENT to make the website not think you are a bot. You can add this command to the terminal command: -s USER_AGENT=’Mozilla/5.0 (Macintosh; Intel Mac OS X 11_5_2) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.2 Safari/605.1.15\nAfterwards, you should have a file generated that has all of the information you need."
  },
  {
    "objectID": "posts/bruin/HW1.html",
    "href": "posts/bruin/HW1.html",
    "title": "SQL Tutorial on Climate",
    "section": "",
    "text": "In this blog, I will be explaining how to construct a database using the Temp, stations, and country datasets."
  },
  {
    "objectID": "posts/bruin/HW1.html#interactive-box-plot",
    "href": "posts/bruin/HW1.html#interactive-box-plot",
    "title": "SQL Tutorial on Climate",
    "section": "Interactive Box Plot",
    "text": "Interactive Box Plot\nWe will now create an interactive box plot for the new pandas dataframe we have created. Again, to connect to the database and create the pandas dataframe, we use a similar method as the previous example. We want to create a function that will allow users to easily change parameters to look for different information in the databse and generate a plot. For this specific example, we want to find the temperature changes in UCLA and USC through the months.  To create the box plot, we will use the following code: fig = px.box(df, x = “x-values”, y = “y-values”, color = “specific column”, width = m, height = n, kwargs) - df: dataframe used to create the plot - x: column used for the x-axis - y: column used for the y-axis - color: color of the box plots - kwargs: additional parameters passed through by the user\n\ndef station_temp_plot(db_file, station_one, station_two, **kwargs) :\n    \"\"\"\n    Creating an interactive box plot that identifies the change in temperature between two stations through the months\n    Function will: \n    1. Use station_climate_comparison_database to create a dataframe with all the information needed\n    2. Creating an interactive box plot\n    \"\"\"\n    # inputting parameters passed through station_temp_plot into station_climate_comparison_database\n    df = station_climate_comparison_database(db_file, station_one, station_two) \n    \n    # creating a interactive box plot (more information regarding arguments above)\n    fig = px.box(df,\n             x = \"NAME\",\n             y = \"Temp\",\n             color = \"Month\",\n             width = 600,\n             height = 300,\n            **kwargs)\n\n    # reduce whitespace\n    fig.update_layout(margin={\"r\":0,\"t\":30,\"l\":0,\"b\":10})\n    return fig\n\nNow that we have finished creating our function, we can run our code!\n\nfig = station_temp_plot(\"temps.db\", station_one = \"U_C_L_A\", station_two = \"LOS_ANGELES_DWTN_USC_CAMPUS\",title=\"Temperature Changes Through the Years at UCLA and USC\")\nfig.show()\n\n\n\n\nThrough this plot, we can see the changes in temperatures throughout the year at UCLA and USC. It is clear that it is colder during the in October, November, December, and Janurary while it gets very hot in July for both USC and UCLA. We can see that the trends are typically what we experience in LA. In addition, when we hover over the box plots, we can see information regaring the maximum, median, minimum etc of a specific month."
  },
  {
    "objectID": "posts/bruin/HW1.html#interactive-scatter-plot",
    "href": "posts/bruin/HW1.html#interactive-scatter-plot",
    "title": "SQL Tutorial on Climate",
    "section": "Interactive Scatter Plot",
    "text": "Interactive Scatter Plot\nNow we will be creating an interactive scatter plot! We will again be using the the same code as above to generate our pandas dataframe. In this function (temp_comparison_plot), we want to look at the changes in temperature through the years at UCLA and USC by the seasons. To do so, we will first like to perform some data cleaning. As observed before, our variable Month consisted of 1 to 12, which represents January to December. Since we will like to perform analysis by season, we want to change the months to their respective season. To do so, we will look through the Month column using the .loc function and changing the numbers to the correct season. Now we can generate our plot!\nWe will be using the following code to generate the scatter plot: fig = px.scatter(data_frame = df, x = “Year”, y = “Temp”, color = “Temp”, hover_data = [“LATITUDE”, “LONGITUDE”], size_max = 8, width = 500, height = 300, opacity = 0.5, facet_col = “Month”, facet_row = “NAME”, **kwargs) - data_frame: dataframe used to create the plot - x: column for our x-axis - y: column for our y-axis - color: column corresponding to the color of the points - hover_data: adding more information for the user to see when they hover over a specific point on the plot - facet_col: splitting the plots columnwise using a specific column from the dataframe - facet_row: splitting the plots rowwise using a specific column from the dataframe\n\ndef temp_comparison_plot(db_file, station_one, station_two, **kwargs) :\n    \"\"\"\n    Creating an interactive scatter plot to look at the changes in temperature through the years at two stations by seasons\n    Function will:\n    1. Use station_climate_comparison_database to create a dataframe that contains all the information needed\n    2. Change the specific months into its corresponding season\n    3. Create the interactive scatter plot\n    \"\"\"\n    # using parameters from temp_comparison_plot into station_climate_comparison_database\n    df = station_climate_comparison_database(db_file, station_one, station_two)\n    \n    # replacing the month's to the season they belong in\n    df.loc[(df['Month']==1) | (df['Month']==2) | (df['Month']==12), 'Month'] = \"Winter\" \n    df.loc[(df['Month']==3) | (df['Month']==4) | (df['Month']==5), 'Month'] = \"Spring\"\n    df.loc[(la['Month']==6) | (df['Month']==7) | (df['Month']==8), 'Month'] = \"Summer\"\n    df.loc[(la['Month']==9) | (df['Month']==10) | (df['Month']==11), 'Month'] = \"Fall\" \n\n    # creating an interactive scatter plot (more information regarding arguments above)\n    fig = px.scatter(data_frame = df,\n                 x = \"Year\",\n                 y = \"Temp\",\n                 color = \"Temp\",\n                 hover_data = [\"LATITUDE\", \"LONGITUDE\"],\n                 size_max = 8,\n                 width = 500,\n                 height = 300,\n                 opacity = 0.5,\n                 facet_col = \"Month\",\n                 facet_row = \"NAME\",\n                 **kwargs)\n\n    #reduce whitespace\n    fig.update_layout(margin={\"r\":0, \"t\":80, \"l\":0, \"b\":0})\n    return fig\n\nNow that we have finished creating our function, lets run it!\n\nfig = temp_comparison_plot(\"temps.db\", station_one = \"U_C_L_A\", station_two = \"LOS_ANGELES_DWTN_USC_CAMPUS\",title=\"Temperature Trends Through the Years by Season &lt;br&gt;in UCLA and USC\")\nfig.show()\n\n\n\n\nFrom the output, we can see the changes in temperature throughout the years. We see that all seasons experienced an increase in temperature from the earliest 1901 to 2021. In addition, UCLA and USC seem to follow the same trends."
  },
  {
    "objectID": "posts/bruin/HW3.html",
    "href": "posts/bruin/HW3.html",
    "title": "Web Design Using Flask",
    "section": "",
    "text": "In this blog, you will be learning how to create a website using flask! The goal is to create a website that contains hyperlinks that will open a text box to allow users to put in a message as well as their name or handle. All of the information will be sorted into a database. There will also be a link to look at all the past messages."
  },
  {
    "objectID": "posts/bruin/HW3.html#get_message_db",
    "href": "posts/bruin/HW3.html#get_message_db",
    "title": "Web Design Using Flask",
    "section": "get_message_db()",
    "text": "get_message_db()\nThe purpose of get_message_db() is to connect or create a database that will store all the messages that is being submitted in our website. To do so, we will create a try and except case. If a database exists, the function will connect to the existing one. In the case that it does not exist, we will create a database.\n\n@app.route('/message') # directory to the message page\ndef get_message_db():\n\"\"\"\nCreating the database if one does not exist \nIf a database does exist, we will get the current one\n\"\"\"\n    try:\n        return g.message_db\n    except AttributeError:\n        # connecting to our database\n        g.message_db = sqlite3.connect(\"messages_db.sqlite\")\n        cursor = g.message_db.cursor()\n        # if table does not exist, create one\n        cursor.execute('''CREATE TABLE IF NOT EXISTS messages\n                          (id INTEGER PRIMARY KEY, handle TEXT, message TEXT)''')\n        g.message_db.commit()\n        return g.message_db\n\nIndentationError: expected an indented block after function definition on line 2 (926931727.py, line 3)"
  },
  {
    "objectID": "posts/bruin/HW3.html#insert_messagerequest",
    "href": "posts/bruin/HW3.html#insert_messagerequest",
    "title": "Web Design Using Flask",
    "section": "insert_message(request):",
    "text": "insert_message(request):\nThe purpose of this function is to take in the user inputs from the website. We are asking users for to submit a message as well as their name/handle. We will then get our database through calling the get_message_db() function and inserting what the user submitted to the site. We also have to make sure we close the connection to our database.\n\ndef insert_message(request):\n\"\"\"\nInputting the user's submissions into the database\n\"\"\"\n    handle = request.form['handle']\n    message = request.form['message']\n\n    con = get_message_db()\n    cur = con.cursor()\n    cur.execute('''INSERT INTO messages (handle, message) VALUES (?, ?)''', (handle, message))\n    \n    con.commit() # commit the messages\n    con.close() # CLOSE THE CONNECTION!"
  },
  {
    "objectID": "posts/bruin/HW3.html#submit",
    "href": "posts/bruin/HW3.html#submit",
    "title": "Web Design Using Flask",
    "section": "submit()",
    "text": "submit()\nThe purpose of this function is to ensure the html files are connected to the functions that we have defined. Above our function, we have included an @app.route(), which creates the add on to our base link. We have two different methods of accessing the site, one through POST and one through GET. The GET when the user tries to get to the submit page by clicking on the hyperlink in the base website. If the user is trying to post, we will use the insert_message() function and then thank the user for their submission.\n\n# Creating a route to the submit page\n@app.route('/submit', methods=['POST', 'GET'])\ndef submit():\n\"\"\"\nCalling the submit.html base on what the user does\nWill either open up the submit page or get the information\nfrom the user's submission\n\"\"\"\n    if request.method == 'GET':\n        return render_template(\"submit.html\")\n    else:\n        # calling insert_message() to input submission to database\n        insert_message(request) \n        # thank you note to user\n        thanks = \"Thank you for your submission!\"\n        return render_template(\"submit.html\", thanks = thanks)"
  },
  {
    "objectID": "posts/bruin/HW3.html#random_messagesn",
    "href": "posts/bruin/HW3.html#random_messagesn",
    "title": "Web Design Using Flask",
    "section": "random_messages(n)",
    "text": "random_messages(n)\nThe purpose of this function is to get the messages and names of the users that have posted on our site. To do so, we will need to establish a connection to our database. Once the connection has been made, we will get all of the messages and handles.\n\ndef random_messages(n):\n\"\"\"\nConnecting to our database and getting the handle and messages\nfrom each user\n\"\"\"\n    # connect to database\n    con = get_message_db()\n    cur = con.cursor()\n    # extracting information\n    cur.execute('''SELECT handle, message FROM messages ORDER BY RANDOM() LIMIT ?''', (n,))\n    messages = cur.fetchall()\n    # close our connection\n    cur.close()\n    return messages"
  },
  {
    "objectID": "posts/bruin/HW3.html#view",
    "href": "posts/bruin/HW3.html#view",
    "title": "Web Design Using Flask",
    "section": "view()",
    "text": "view()\nThe purpose of the view() function is to create a route form the base website that shows the different messages that have been submitted by previous users. To do so, we will all the random_messages(n) function to get the information we need. In this case, I have made it so that n equals 5. Therefore, we will be getting 5 random messages from our database. Then we will set a connection to the view.html to upload the messages we have extracted.\n\n# creating a new route from base website\n@app.route('/view')\ndef view():\n\"\"\"\nGetting 5 random messages from database and uploading\nit to the view.html\n\"\"\"\n    messages = random_messages(5)\n    return render_template(\"view.html\", messages=messages)\n        \nif __name__ == '__main__':\n    app.run(debug=True)\n\nThat is all for the app.py files! The next section will be talking about the html files in our templates folder."
  },
  {
    "objectID": "posts/bruin/index.html",
    "href": "posts/bruin/index.html",
    "title": "Heat Diffusion",
    "section": "",
    "text": "In this blog, I will be going over how to simulate two-dimensional heat diffusion in various ways.  We will use the equation below to simulate two-dimensional heat diffusion as a sequence of matrix-vector multiplications.\n  u  i , j   k + 1   ≈  u  i , j  k  + ϵ  (  u  i + 1 , j  k  +  u  i − 1 , j  k  +  u  i , j + 1  k  +  u  i , j − 1  k  − 4  u  i , j  k  )  , \nFor this specific example, we will be setting N = 101 and epilson = 0.2\nTo begin, let’s import all the necessary libraries.\n\nimport numpy as np\nfrom matplotlib import pyplot as plt\nimport timeit\nimport jax\nfrom jax.experimental import sparse\nfrom jax import jit\nimport jax.numpy as jnp\n\n\nMatrix Multiplication\nFirst, let’s try to create this simulation using matrix multiplication.\n\nfrom heat_equation import advance_time_matvecmul\nimport inspect\nprint(inspect.getsource(advance_time_matvecmul))\n\ndef advance_time_matvecmul(A, u, epsilon):\n    \"\"\"Advances the simulation by one timestep, via matrix-vector multiplication\n    Args:\n        A: The 2d finite difference matrix, N^2 x N^2. \n        u: N x N grid state at timestep k.\n        epsilon: stability constant.\n\n    Returns:\n        N x N Grid state at timestep k+1.\n    \"\"\"\n    N = u.shape[0]\n    u = u + epsilon * (A @ u.flatten()).reshape((N, N))\n    return u\n\n\n\nThe purpose of the function is to return the updated matrix after one timestep. We will later use this function to iterate through 2700 times to observe the heat diffusion.\nNext, let us create a function called get_A(N).\n\nfrom heat_equation import get_A\nimport inspect\nprint(inspect.getsource(get_A))\n\ndef get_A(N) :\n    \"\"\"\n    Takes in the dimensions, N\n    Creates the corresponding matrix\n    \"\"\"\n    n = N * N\n    diagonals = [-4 * np.ones(n), np.ones(n-1), np.ones(n-1), np.ones(n-N), np.ones(n-N)]\n    diagonals[1][(N-1)::N] = 0\n    diagonals[2][(N-1)::N] = 0\n    A = np.diag(diagonals[0]) + np.diag(diagonals[1], 1) + np.diag(diagonals[2], -1) + np.diag(diagonals[3], N) + np.diag(diagonals[4], -N)\n    return A\n\n\n\nThis function will take in the dimensions we have preset, which is 101 and generate a matrix without all-zero rows or all-zero columns.\nNow, let us use the two functions we have defined above to create a simulation of the heat diffusion after 2700 iterations. Let’s also output the heat diffusion after ever 300 iterations. Therefore, we should create an empty list to store NxN grid state. Since we will be creating this simulation in various ways, we should also calculate the amount of time it takes for this simulation to run. In the end, we will compare and see which method takes the least amount of time!\n\nN = 101 # dimension\nepsilon = 0.2\nplots = [] # empty list\nmatrix = get_A(N) # getting inital array\n\nu = np.zeros((N, N)) # defining u to be passed through advance_time_matvecmul\nu[int(N/2), int(N/2)] = 1.0\n\nstart = timeit.default_timer() # getting the start time\n\nfor i in range(1, 2701) : # iterating through 2700 times\n    u = advance_time_matvecmul(matrix, u, epsilon) \n    if i % 300 == 0 : # after every 300th iteration, save the NxN grid state\n        plots.append(u)\n        \nstop = timeit.default_timer() # getting the end time\nexecution_time = stop - start # calculating the time it took to run\nprint(\"Time elapsed:\", execution_time)\n\nTime elapsed: 21.823670458048582\n\n\nTo observe our plots, we can run the for loop below to visualize the heat diffusion.\n\nfor i in range(len(plots)) :\n    plt.subplot(3, 3, i+1)\n    plt.imshow(plots[i])\n\n\n\n\n\n\n\n\nWe can see from our results that this methodology took a very long time to run. Therefore, it might not be the most efficient method. Let’s see if there is another way to perform the same simulation.\n\n\nSparse matrix in JAX\nLet’s use the data structure that exploits a lot of zeros in the matrix A, which utiliziees the sparse matrix data structures. In addition, the JAX package holds an experimental sparse matrix support through utilizing jnp.\nWe can use the same function advance_time_matvecmul to get the NxN grid state. However, let’s use a different method to create the matrix. We will define a function called get_sparse_A.\n\nfrom heat_equation import get_sparse_A\nprint(inspect.getsource(get_sparse_A))\n\ndef get_A(N) :\n    \"\"\"\n    Takes in the dimensions, N\n    Creates the corresponding matrix\n    \"\"\"\n    n = N * N\n    diagonals = [-4 * np.ones(n), np.ones(n-1), np.ones(n-1), np.ones(n-N), np.ones(n-N)]\n    diagonals[1][(N-1)::N] = 0\n    diagonals[2][(N-1)::N] = 0\n    A = np.diag(diagonals[0]) + np.diag(diagonals[1], 1) + np.diag(diagonals[2], -1) + np.diag(diagonals[3], N) + np.diag(diagonals[4], -N)\n    return A\n\n\n\nIn this function, we are still using the get_A to generate our inital matrix. However, the JAX library is only able to read in jnp array’s and not np array’s. Therefore, we will need to convert the array into jnp format. The sparse.BCOO.fromdense function is a batched coordinate sparse array, which offers a compressed storage format. This will allow our code to run a lot faster and be more efficient. In addition, we want to make sure we use the jited version of advance_time_matvecmul as this allows jax to perform an optimized calculation.\n\nN = 101 # dimension\nepsilon = 0.2 \nu = np.zeros((N, N)) # reseting u\nu[int(N/2), int(N/2)] = 1.0\n\nplots = [] # list to insert NxN grid state\n\njitted = jax.jit(advance_time_matvecmul) # \n\nmatrix = get_sparse_A(N) # getting the matrix using the new function we defined\nstart = timeit.default_timer() # getting start time\nfor i in range(1, 2701) : # looping through 2700 iterations\n    u = jitted(matrix, u, epsilon) # using jitted function\n    if i % 300 == 0 : # getting every 300th iteration\n        plots.append(u) # adding to the list\nstop = timeit.default_timer() # getting stop time\nexecution_time = stop - start # calculating the duration\nprint(\"Time elapsed:\", execution_time)\n\nTime elapsed: 0.8979862499982119\n\n\nWe can see that using the sparse matrix in JAX, the heat diffusion simulation was a lot faster than our previous method. It was about 10x faster. Let’s take a look at the plots and see if we got the same result.\n\nfor i in range(len(plots)) :\n    plt.subplot(3, 3, i+1)\n    plt.imshow(plots[i])\n\n\n\n\n\n\n\n\n\n\nDirect Operation with Numpy\nIn this example, we will be using numpy to advance the solution by one timestep. We will be using vectorized array operation, like np.roll().\n\nfrom heat_equation import advance_time_numpy\nprint(inspect.getsource(advance_time_numpy))\n\ndef get_sparse_A(N) :\n    \"\"\"\n    Takes in the dimensions, N\n    Utilizies previously defined function and changing it to a jnp array\n    Puts the array into a sparse array\n    \"\"\"\n    A = get_A(N)\n    j_array = jnp.array(A)\n    A_sp_matrix = sparse.BCOO.fromdense(j_array)\n    return A_sp_matrix\n\n\n\nWe will now use our new function for the simulation.\n\nepsilon = 0.2 \nplots = []\n\nu = np.zeros((N, N))\nu[int(N/2), int(N/2)] = 1.0\n\nstart = timeit.default_timer() \nfor i in range(1, 2701) :\n    u = advance_time_numpy(u, epsilon) \n    if i % 300 == 0 :\n        plots.append(u)\nstop = timeit.default_timer()\nexecution_time = stop - start\nprint(\"Time elapsed:\", execution_time)\n\nTime elapsed: 0.2789691670332104\n\n\nWow! We can see that numpy runs abour 100x times faster than our first method! Let’s view our plots for the simulation.\n\nfor i in range(len(plots)) :\n    plt.subplot(3, 3, i+1)\n    plt.imshow(plots[i])\n\n\n\n\n\n\n\n\n\n\nWith JAX\nSimilarly to the numpy function above, we will instead be using jnp instead of np.\n\nfrom heat_equation import advance_time_jax\nprint(inspect.getsource(advance_time_jax))\n\ndef advance_time_numpy(u, epsilon) :\n    \"\"\"\n    Takes in the NxN grid state and episilon\n    Using the heat diffusion equation\n    Using np.roll to generate the boundary condition\n    Returns the new grid state after advancing by one timestep\n    \"\"\"\n    padded = np.pad(u, 1, mode = 'constant') # modifies array by padding edges\n    np_u = padded + epsilon * (np.roll(padded, 1, axis = 1) + \n                               np.roll(padded, -1, axis = 1) + \n                               np.roll(padded, -1, axis = 0) + \n                               np.roll(padded, 1, axis = 0) - \n                               (4 * padded))\n    np_u_slc = np_u[1:-1, 1:-1]\n    return np_u_slc\n\n\n\nYou can observe from about that in every instance that we used np, we switched it into jnp as jax only runs with jnp arrays. Now, let’s fun our function!\n\nepsilon = 0.2\nplots = []\n\nu = np.zeros((N, N))\nu[int(N/2), int(N/2)] = 1.0\n\njitted_jax = jax.jit(advance_time_jax) # remember to jit!\nstart = timeit.default_timer()\nfor i in range(1, 2701) :\n    u = jitted_jax(u, epsilon) \n    if i % 300 == 0 :\n        plots.append(u)\nstop = timeit.default_timer()\nexecution_time = stop - start\nprint(\"Time elapsed:\", execution_time)\n\nTime elapsed: 0.09186283400049433\n\n\nWe have to remember to jit our function as well similar to what we did in part 2. Looking at our execution time, we can see that the JAX method performed the fastest out of all the methods!\n\n\nComparison\nOut of all of the methods, the slowest was generating our own functions. This does not utilize a lot of efficient libraries that can help speed up the run time of our simulation. It took about 21.8 seconds to run through 2700 simulations. We can see that if we use the same approach while using JAX, it helps to speed the process up to around 0.89 seconds. Just simply using the JAX library with our own defined function was able to speed the simulation up by 20x. Next, we also recreated our inital function of advancing the simulation by one timestep through using the np.roll method. This significantly sped up the processes without the need to use JAX. In fact, it out performed the first and second method with a run time of 0.28 seconds. Impressive right?! Next, let’s see how our newly created function would work if we used the JAX library. We see that using the JAX library on our numpy function, our simulation ran in 0.092 seconds. Through comparing all of these simulations, we see that using the JAX library can significantly optimize and decrease our run time. Though it might be a little hard to understand what each function does in the JAX library, once you understand it, it makes coding the heat diffusion simulation a lot simplier. In addition, understanding the math behind the function will also help a lot. If you are proficient in these topics, creating the heat simulation with JAX is a lot simplier than using matrix multiplication and numpy.\n\n\nFinal Takeaways\nThrough creating the heat diffusion simulation in various ways, we see that using the JAX library is extremely helpful and runs really quickly. Therefore, it is more common to use JAX over numpy especially when working with very large amounts of data!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "myblog",
    "section": "",
    "text": "Heat Diffusion\n\n\n\n\n\n\nWeek 7\n\n\nHW4\n\n\n\n\n\n\n\n\n\nFeb 23, 2024\n\n\nShaina Wang\n\n\n\n\n\n\n\n\n\n\n\n\nWeb Design Using Flask\n\n\n\n\n\n\nWeek 6\n\n\nHW3\n\n\n\n\n\n\n\n\n\nFeb 12, 2024\n\n\nShaina Wang\n\n\n\n\n\n\n\n\n\n\n\n\nWeb Scrapping TMDB\n\n\n\n\n\n\nWeek 5\n\n\nHW2\n\n\n\n\n\n\n\n\n\nFeb 12, 2024\n\n\nShaina Wang\n\n\n\n\n\n\n\n\n\n\n\n\nSQL Tutorial on Climate\n\n\n\n\n\n\nWeek 3\n\n\nHW1\n\n\n\n\n\n\n\n\n\nJan 29, 2024\n\n\nShaina Wang\n\n\n\n\n\n\n\n\n\n\n\n\nContructing data visualization of the Palmer Penguin data set\n\n\n\n\n\n\nWeek 1\n\n\nHW0\n\n\n\n\n\n\n\n\n\nJan 20, 2024\n\n\nShaina Wang\n\n\n\n\n\n\nNo matching items"
  }
]